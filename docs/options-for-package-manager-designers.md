# Socio-technical options for package manager designers #

A wide design space has already been explored by creators of package
managers so far.  However, there has been no surveys describing the
various options available, and their possible consequences.  This is
an attempt at starting such a categorization.

## Options for package registries ##

There are a number of technical options to implement a package
registry.  Some will have consequences on the package manager
(client); some will have social / cultural consequences on the way the
ecosystem is organized.  Finally, there are also some policy options
that can be related to, or independent from technical assumptions, and
which can naturally have social / cultural consequences as well.  For
a review of the cultural differences among different package
ecosystems, see ["Culture and Breaking Change: A Survey of Values and
Practices in 18 Open Source Software
Ecosystems"](https://figshare.com/articles/Culture_and_Breaking_Change_A_Survey_of_Values_and_Practices_in_18_Open_Source_Software_Ecosystems/5108716).

### What is uploaded to the registry? ###

The registry can accept uploads containing only package meta-data, in
which case the meta-data should contain a URL for the sources, from
which the registry or the end-user (client) may fetch them.  Or, it
can require package upload to contain sources as well, or even
pre-built binaries.

If the registry does not require uploading pre-built binaries, then
the package meta-data typically contains build instructions that can
be executed, either by the registry, or by the package manager.

Historic package repositories such as CTAN, CPAN, CRAN, Debian,
require the uploading of the sources.  This ensures that the registry
can continue to serve them even if the official source location is
down.

This is also the case of more modern registries like RubyGems.
However, while Ruby packages generally contain only source code (Ruby
being an interpreted language), nothing prevents anyone from including
pre-built binaries in their packages.

Similarly, npm accepts packages containing any kind of content, either
interpreted source code, or pre-built binaries.

Finally, package repositories like opam, MELPA, or nixpkgs only accept
package meta-data to be uploaded.

### What is distributed by the registry? ###

The registry makes available at least some meta-data for each package,
but it may, in addition, serve the sources of the package, and
possibly a pre-built version.  If the registry serves the sources but
does not require uploading them, then it must mirror them.  If the
registry serves pre-built binaries but does not require uploading
them, then it must be able to build them automatically.

For instance, opam serves only the package meta-data, while nixpkgs
serves package meta-data and provides a binary cache that can be used
in substitution to install packages that have been built on the
server.  Finally Debian serves package meta-data, source code, and
binaries.

### Type of storage ###

The traditional approach is to host an archive containing
hierachically-organized files (either just package manifests, or even
their source code).  This is a technically simpler solution as it is
easy to set up a new archive, to mirror an existing one, or to copy
the entire content of the archive locally (especially when the archive
only contains package manifests).

This archive can optionally be versioned as a whole, for instance as a
git repository hosted on GitHub.  In this case, the package manager
can be configured to fetch the archive using git or the tarball
automatically generated by GitHub.

For instance CocoaPods, homebrew, and nixpkgs use a git repository to
store the content of the whole archive, and the archive can be fetched
directly from GitHub.

Nowadays, there are many registries that rely on a database instead.
This is the case in particular of npm, RubyGems, and PyPI.

### How can the registry be browsed? ###

In the case the registry is an archive, its content can be accessible
through protocols like FTP or HTTP ("file-system based registry"), or
the full archive can be only downloaded as a large tarball, to be
unpacked and browsed locally ("portable registry").

A combination of both is also possible: for instance, an opam registry
serves both individual package manifests and a tarball containing the
content of the whole archive and used to synchronize a local copy.

In the case the registry is a database, it is typically accessible
through a RESTful API (although other types of APIs like a GraphQL API
are also possible).  This API may be documented or not depending on
whether the authors of the registry view this API as a public
interface that anyone can rely on, or as an entirely private interface
to be used only between their registry and the package manager
associated with it.  However, stable and documented APIs are useful
not just to build competiting package managers (clients), but also to
build services like [Libraries.io](https://libraries.io/) that present
information about packages differently.

It is possible for an archive-based registry to still provide an API.
For instance, this is the case of CPAN.

When a registry is accessible through an API, it usually provides an
endpoint to list all the packages available, but this endpoint may
return incomplete results, in particular if there is a notion of
private packages.

### Access control to download a package ###

Accessing the entire registry or a subset of packages may be
restricted to properly authenticated and authorized individuals.

An entreprise registry, as is supported by npm, would typically
require authentication to access anything from the registry.  Some
registries also support publishing both public and private packages.
This is the case of npm, and of GitHub's registry.  Authentication is
only necessary to access private packages.

### Technology to publish a new package ###

Package upload can be handled by the same tool as package download
(the package manager), or by some other tool.  A solution that is very
easy to implement is to create a GitHub repository of package
meta-data (manifest files) and to allow uploading a package by
creating a pull request.  For users, it is likely however to be a more
complex workflow than having a publish command in the package manager.
Some wrapper tool, like
[opam-publish](https://github.com/ocaml/opam-publish), can be provided
to automate as much of this workflow as possible.

An alternative solution adopted by many early package registries is to
have a web-form to submit a new package.

### Access control / policy to publish a new package ###

Most registries that accept publishing through a command will require
the user setting up an account first, but registration will be open to
anyone and effective immediately.  Some, like CPAN, have an account
application process.

The registries that rely on pull requests to add or update packages
usually have a peer-review process to ensure that the package
meta-data meets some basic standards (but this does not mean that the
content of the package itself is reviewed).  They usually do not
require the person publishing the package to the registry to have any
connection with the package author (which on the other hand is assumed
in registries relying on a publishing tool).

Note that the review process may not scale properly unless specific
efforts are made to extend the reviewer team.  While the review
process is likely to result in higher quality package, it may also
incentivize package authors to put less effort to prepare their
submission because they can rely on the review to catch problems
(cf. this [blog post from
CocoaPods](http://blog.cocoapods.org/CocoaPods-Trunk/)).

Finally, some registries can have a peer-review process of the package
content before they accept it.  This is (or was, since no new package
have been accepted since 2013) the case of PEAR, the first PHP package
registry.  Every package submission required its own RFC (Request For
Comments) and ended up with a vote.

### Technology to publish a new version ###

In most cases, the technology for publishing a new version is the same
as for publishing a new package, but there are some exceptions.  For
registries where package submission is via a web-form, it can be the
case that the maintainer of the package then gets granted a more
direct access to the archive, where they can upload new versions
without going through the form again.  In some registries, each
package gets its own version control repository, in which case new
versions are published through this repository.

For instance, the conda-forge registry accepts submission of new
packages through pull requests on a [central
repository](https://github.com/conda-forge/staged-recipes), but
afterwards, a new GitHub repository is created on which the maintainer
can upload new versions with or without peer-review.

Finally, new versions of a package can be automatically picked from
its development repository.  This is the case of MELPA: the initial
submission is via a pull request on a GitHub repository, but then
every new commit is considered to constitute a new version.  MELPA
Stable only considers the subset of tagged commits.

### Access control / policy to publish a new version ###

Most package registries which accept publishing via a tool will
consider that publishing a new version can only be done by the user
who published the first version, or other users that have been
delegated permission.  This is also the case for more traditional
registries like CTAN, CPAN, CRAN, and Debian, and of conda-forge for
which the initial submission is via a pull request.

It is interesting to note that while application-specific package
registries allowing submission via a tool usually assume that the
submission is by the author of the package, this is not the case of
system package registries like Debian, Homebrew, or nixpkgs, nor of
the application-specific registry conda-forge.  Thus the person (or
persons) that are allowed to publish new versions in the latter
registries differ from the development team of the corresponding
package.

The Elm package manager is special in that it does not have its own
authentication system, and instead piggy-backs on GitHub's own access
control.  It considers that anyone with the permission of publishing a
new tag on a GitHub repository is legitimate to publish a new version
on the package registry.

For package registries that allow submission of a new version through
a pull request, the new version will undergo the same kind of review
as for a first version.  It is usually not necessary that the
submission of the new version is done by the user who submitted the
first version.

Finally, it is worth noting that while some ecosystems value very
short release cycles, others like R / CRAN do not, because of the
heavy review process. On the [CRAN policy
page](https://cran.r-project.org/web/packages/policies.html), we can
read:

> Submitting updates should be done responsibly and with respect for
> the volunteers’ time. Once a package is established (which may take
> several rounds), "no more than every 1–2 months" seems appropriate.


### Package naming ###

Most package registries accept any name (in a restricted character set
that typically includes alpha-numeric characters, dashes and / or
underscores).  However, more and more package registries allow (or
enforce) scoping, which means that the name is composed of two parts
(usually separated by a slash), the first one is the name of the owner
(individual or team), and the second part is the name of the project.

For instance, npm supports scoped and unscoped package names (but only
scoped names are authorized for private packages), while the Elm
package manager and GitHub's package registry require scoped package
names.

### Removing a version or a package ###

It is usually considered a bad practice to remove a version of a
package after it has been published.  This was authorized nonetheless
by several package managers like npm, until they decided to restrict
this practice after the leftpad incident (cf. this [blog
post](https://blog.npmjs.org/post/141905368000/changes-to-npms-unpublish-policy)).

GitHub's registry similarly restricts any package or version removal
(exceptions may be granted in special cases by contacting GitHub
staff).

When packages are submitted through pull requests on a repository, the
maintainers of the repository will generally reject pull requests
removing packages except in very specific cases.  However, they may
accept pull request fixing package manifest files, even though doing
so without amending the version number would be considered bad
practices in other ecosystems (such as Debian).

Some package registries, in particular for system package managers,
prefer to keep a single version available, and in this case it is
normal practice to remove older versions (this is just an update to
the package and the version number is changed).

Finally, note that in registries striving to provide a consistent set
of packages at a single version, like Debian, but also like CRAN or
Stackage, packages may be removed from the set when they do not build
with the available versions of their dependencies.

### Tooling for collaboration and development ###

The package registry may make some development tools available either
optionally or automatically.  Tools can include a version control
system, a bug tracker, continuous integration, etc.

This was most useful before the rise of very large software forges
like GitHub, which make it easy for anyone to have access to this kind
of tooling today, and imposing every package to be developed in the
same place is not likely to be successful.

However, when publishing a package to the registry is not done by the
same people as the package development (as in Debian, Homebrew, or
opam), it can be useful to have an bug tracker to report issues
specific to the package and not the underlying software.

### Automated checks ###

Linters are useful to avoid frequent mistakes.  They are usually
applied to the manifest file, either by the publishing tool, or via
continuous integration on the package repository.  It is generally
helpful to be able to run the linter locally, and without publishing
anything in case the linter is successful, so the linter but be made
available as a separate command, even if it is run automatically by
the publish command.

Continuous integration can also test the build of the package either
before, or after it is submitted.

### Version curation ###

Some registries intend to provide a curated set of packages.  This
includes registries for system package managers, e.g. Debian, but also
application-specific registries like Stackage, which is a curated
version of Hackage, the Haskell package registry.

Only providing a curated registry in a given ecosystem may lead to
frustration from some users wanting to rely on older releases.

### Delay to release ###

A lot of application-specific registries, and some registries for
system package managers, make packages available very soon after they
have been submitted: this is the rolling release model.

On the other hand, curated registries are more likely to have a
release cycle with release events when the whole public registry is
updated at once.  For the users who want stability, this is usually a
great solution, but for some other users who want to take advantage of
new versions as soon as they are available, it can be frustrating if
the main registry in the ecosystem is not on a rolling release model.
This is for instance the case of the R ecosystem (CRAN is curated and
new versions of packages are only distributed with new releases of the
R language), and it leads maintainers of actively developed packages
to host their own registries (cf. this [blog
post](https://ropensci.org/blog/2015/08/04/a-drat-repository-for-ropensci/)
for instance).

## Options for manifest files ##

### File format ###

### Version of the package ###

### Versions of the dependencies ###

## Options for package indexes ##

### Package sorting ###

### Package search and filtering mechanisms ###

### Measures to display ###

### Embedded documentation ###

## Options for package managers (clients) ##

### Multi-registry support ###

### System-wide, user-wide, mutli-profile, or project-local installation ###

### Local binary cache ###

### Manage dependency updates ###

### Manage build ###

